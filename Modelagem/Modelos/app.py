# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Vqe9tD1MLQZwX_uZzwzlriQdM_2e5zzb
"""

# App.py teste, serve para testar funcionalidades este arquivo ainda não esta finalizado, nem editado para melhor manutenabilidade do mesmo

import os
import traceback
import pandas as pd
import numpy as np
import joblib
from flask import Flask, request, jsonify
from sklearn.base import BaseEstimator, TransformerMixin

# --- DEFINIÇÃO DA CLASSE (Versão EXATA do Treino) ---


class ExtratorDeDatas(BaseEstimator, TransformerMixin):
    def fit(self, X, y=None):
        return self

    def transform(self, X):
        X_copy = X.copy()
        # Garante que é uma Series ou pega a primeira coluna do DF
        if isinstance(X_copy, pd.DataFrame):
            series = X_copy.iloc[:, 0]
        else:
            series = X_copy

        # Converte para datetime (dayfirst=True prioriza formato DD/MM/AAAA)
        dt_series = pd.to_datetime(series, dayfirst=True, errors='coerce')

        return pd.DataFrame({
            'mes': dt_series.dt.month,
            'dia_semana': dt_series.dt.dayofweek,
            'hora': dt_series.dt.hour,
            'dia_ano': dt_series.dt.day_of_year
        })


# --- CONFIGURAÇÃO DA API ---
app = Flask(__name__)
# Atualizado para o novo nome do arquivo solicitado
MODEL_PATH = 'modelo_previsao_voos.bin'
model = None
model_loaded = False
model_type = None


class ModelAdapter:
    """Adapter to provide `predict` and `predict_proba` for different model types."""

    def __init__(self, raw, kind):
        self.raw = raw
        self.kind = kind

    def predict(self, X):
        if self.kind == 'sklearn':
            return self.raw.predict(X)
        if self.kind == 'lightgbm':
            preds = self.raw.predict(X.values)
            return (np.asarray(preds) > 0.5).astype(int)
        if self.kind == 'xgboost':
            import xgboost as xgb
            dmat = xgb.DMatrix(X.values)
            preds = self.raw.predict(dmat)
            return (np.asarray(preds) > 0.5).astype(int)
        if self.kind == 'catboost':
            # CatBoost returns array-like
            return np.asarray(self.raw.predict(X))
        raise RuntimeError('Unknown model kind')

    def predict_proba(self, X):
        if self.kind == 'sklearn':
            if hasattr(self.raw, 'predict_proba'):
                return self.raw.predict_proba(X)
            # fallback: create prob column from decision_function if available
            return None
        if self.kind == 'lightgbm':
            preds = self.raw.predict(X.values)
            preds = np.asarray(preds)
            if preds.ndim == 2:
                return preds
            return np.vstack([1 - preds, preds]).T
        if self.kind == 'xgboost':
            import xgboost as xgb
            dmat = xgb.DMatrix(X.values)
            preds = self.raw.predict(dmat)
            preds = np.asarray(preds)
            if preds.ndim == 2:
                return preds
            return np.vstack([1 - preds, preds]).T
        if self.kind == 'catboost':
            if hasattr(self.raw, 'predict_proba'):
                return np.asarray(self.raw.predict_proba(X))
            preds = np.asarray(self.raw.predict_proba(X)) if hasattr(
                self.raw, 'predict_proba') else None
            return preds
        return None


# Mapeamento: O que vem no JSON -> Nome da coluna no Modelo
DE_PARA_COLUNAS = {
    "companhia": "sg_empresa_icao",
    "origem": "sg_iata_origem",
    "destino": "sg_iata_destino",
    "data_partida": "dt_partida_prevista"
}

# Valores padrão para campos OBRIGATÓRIOS do modelo que NÃO vêm no JSON
# Importante: Esses valores influenciam a previsão. Foi utilizado a moda, mas pode ser melhora trocar valores
# Os valores esperados estão comentados, estes valores são apenas para aqueles que não viram no JSON
VALORES_PADRAO = {
    'nr_assentos_ofertados': np.int64(186),
    # 'dt_partida_prevista': '19/01/2023 15:00',
    # 'sg_iata_origem': 'GRU',
    # 'sg_iata_destino': 'GRU',
    'nr_voo': '0248',
    # 'sg_empresa_icao': 'AZU',
    'cd_tipo_linha': 0,
    'sg_equipamento_icao': 'A320'}

try:
    print(f"Carregando modelo: {MODEL_PATH}...")
    if not os.path.exists(MODEL_PATH):
        raise FileNotFoundError(
            f"Arquivo do modelo não encontrado: {MODEL_PATH}")
    # 1) Tentativa padrão: joblib (sklearn pipeline)
    try:
        m = joblib.load(MODEL_PATH)
        if m is None:
            raise RuntimeError("joblib.load retornou None")
        model = ModelAdapter(m, 'sklearn')
        model_type = 'sklearn'
        model_loaded = True
        print("Modelo carregado com sucesso via joblib (sklearn).")
    except Exception as e_joblib:
        print('joblib.load falhou, tentando loaders alternativos...', e_joblib)
        # 2) Tentar LightGBM
        try:
            import lightgbm as lgb
            booster = lgb.Booster(model_file=MODEL_PATH)
            model = ModelAdapter(booster, 'lightgbm')
            model_type = 'lightgbm'
            model_loaded = True
            print('Modelo carregado via LightGBM Booster.')
        except Exception as e_lgb:
            print('lightgbm load falhou:', e_lgb)
            # 3) Tentar XGBoost
            try:
                import xgboost as xgb
                b = xgb.Booster()
                b.load_model(MODEL_PATH)
                model = ModelAdapter(b, 'xgboost')
                model_type = 'xgboost'
                model_loaded = True
                print('Modelo carregado via XGBoost Booster.')
            except Exception as e_xgb:
                print('xgboost load falhou:', e_xgb)
                # 4) Tentar CatBoost
                try:
                    from catboost import CatBoost
                    cb = CatBoost()
                    cb.load_model(MODEL_PATH)
                    model = ModelAdapter(cb, 'catboost')
                    model_type = 'catboost'
                    model_loaded = True
                    print('Modelo carregado via CatBoost.')
                except Exception as e_cat:
                    print('catboost load falhou:', e_cat)
                    raise RuntimeError(
                        f"Falha ao carregar modelo por todos os loaders. Último erro: {e_cat}")
except Exception as e:
    print(f"ERRO CRÍTICO ao carregar modelo: {e}")
    traceback.print_exc()
    print("Dica: Verifique se o scikit-learn instalado é >= 1.3 (necessário para TargetEncoder).")


@app.route('/predict', methods=['POST'])
def predict():
    if not model_loaded:
        # Return a deterministic fallback prediction for integration tests
        fallback_prediction = 0
        fallback_prob = 0.0
        return jsonify({
            'status': 'warning',
            'message': 'Modelo indisponível, usando fallback.',
            'previsao': 'No Horário' if fallback_prediction == 0 else 'Atrasado',
            'probabilidade': float(fallback_prob),
            'prediction': int(fallback_prediction),
            'probability': float(fallback_prob)
        }), 200

    try:
        data_json = request.get_json()
        if not data_json:
            return jsonify({'status': 'error', 'message': 'JSON vazio.'}), 400

        # 1. Validação dos campos esperados na interface (contrato simplificado)
        expected = ['companhia', 'origem', 'destino', 'data_partida']
        missing_input = [k for k in expected if k not in data_json]
        if missing_input:
            return jsonify({'status': 'error', 'message': f'Campos faltando na entrada: {missing_input}'}), 400

        # 2. Construção do dicionário final com as features exatamente na forma esperada pelo modelo
        # Features esperadas (investigadas no bin):
        # ['sg_empresa_icao','sg_icao_origem','sg_icao_destino','sg_equipamento_icao',
        #  'nr_assentos_ofertados','cd_tipo_linha','mes_partida','dia_semana','hora_partida']
        dados_modelo = {}

        # Mapear valores vindos do wrapper/Java
        dados_modelo['sg_empresa_icao'] = data_json.get('companhia')
        dados_modelo['sg_icao_origem'] = data_json.get('origem')
        dados_modelo['sg_icao_destino'] = data_json.get('destino')

        # Equipamento e assentos — usar defaults se não fornecido
        dados_modelo['sg_equipamento_icao'] = data_json.get(
            'sg_equipamento_icao', VALORES_PADRAO.get('sg_equipamento_icao', 'A320'))
        dados_modelo['nr_assentos_ofertados'] = data_json.get(
            'nr_assentos_ofertados', VALORES_PADRAO.get('nr_assentos_ofertados', np.int64(186)))

        # Tipo de linha: garantir inteiro
        dados_modelo['cd_tipo_linha'] = int(data_json.get(
            'cd_tipo_linha', VALORES_PADRAO.get('cd_tipo_linha', 0)))

        # Extrair mês, dia da semana e hora a partir de data_partida
        try:
            dt = pd.to_datetime(data_json.get('data_partida'),
                                dayfirst=False, errors='coerce')
            dados_modelo['mes_partida'] = int(
                dt.month) if not pd.isna(dt) else 1
            dados_modelo['dia_semana'] = int(
                dt.dayofweek) if not pd.isna(dt) else 0
            dados_modelo['hora_partida'] = int(
                dt.hour) if not pd.isna(dt) else 0
        except Exception:
            dados_modelo['mes_partida'] = 1
            dados_modelo['dia_semana'] = 0
            dados_modelo['hora_partida'] = 0

        # 3. Criação do DataFrame com a ordem de colunas estável
        feature_order = ['sg_empresa_icao', 'sg_icao_origem', 'sg_icao_destino', 'sg_equipamento_icao',
                         'nr_assentos_ofertados', 'cd_tipo_linha', 'mes_partida', 'dia_semana', 'hora_partida']
        df_input = pd.DataFrame([{k: dados_modelo.get(k)
                                for k in feature_order}])

        # 4. Predição
        raw_pred = model.predict(df_input)
        # raw_pred may be a class label or a raw margin/score
        raw0 = np.asarray(raw_pred)[0]

        # 5. Probabilidade: prefer predict_proba, fallback to sigmoid(raw)
        prob_delay = 0.0
        probs = None
        try:
            probs = model.predict_proba(df_input)
        except Exception:
            probs = None

        if probs is not None:
            p0 = np.asarray(probs)[0]
            if p0.ndim > 0 and len(p0) > 1:
                prob_delay = float(p0[1])
            else:
                prob_delay = float(p0[0])
        else:
            # Convert raw margin to probability via sigmoid
            try:
                prob_delay = float(1.0 / (1.0 + np.exp(-float(raw0))))
            except Exception:
                prob_delay = 0.0

        # 6. Formatação da Saída (Contrato do Java)
        prediction_label = 1 if prob_delay > 0.5 else 0
        status_texto = "Atrasado" if prediction_label == 1 else "No Horário"

        return jsonify({
            "previsao": status_texto,
            "probabilidade": float(round(prob_delay, 2)),
            "prediction": int(prediction_label),
            "probability": float(prob_delay)
        })

    except Exception as e:
        # Log do erro no console do servidor para debug
        print(f"Erro no processamento: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500


@app.route('/health', methods=['GET'])
def health():
    status = 'UP' if model_loaded else 'DEGRADED'
    code = 200 if model_loaded else 503
    return jsonify({'status': status, 'service': 'modelos-ml', 'model_loaded': model_loaded}), code


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)
